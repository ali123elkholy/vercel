import fs from 'fs';
import { posix as pathPosix } from 'path';
import { glob, debug, type FileFsRef } from '@vercel/build-utils';

export const GIN_ENTRYPOINT_FILENAMES = ['main', 'server', 'index', 'app'];
export const GIN_ENTRYPOINT_DIRS = ['', 'api', 'cmd', 'src', 'app'];

// Detects a minimal set of Gin-specific imports/usages
export const GIN_CONTENT_REGEX =
  /("github.com\/gin-gonic\/gin"|gin\.Default\(|gin\.New\(|gin\.Engine)/;

export const GIN_CANDIDATE_ENTRYPOINTS = GIN_ENTRYPOINT_FILENAMES.flatMap(
  (filename: string) =>
    GIN_ENTRYPOINT_DIRS.map((dir: string) =>
      pathPosix.join(dir, `${filename}.go`)
    )
);

export function isGinEntrypoint(
  file: FileFsRef | { fsPath?: string }
): boolean {
  try {
    const fsPath = (file as FileFsRef).fsPath;
    if (!fsPath) return false;
    const contents = fs.readFileSync(fsPath, 'utf8');
    return GIN_CONTENT_REGEX.test(contents);
  } catch {
    return false;
  }
}

/**
 * Detect a Gin entrypoint path relative to workPath, or return null if not found.
 */
export async function detectGinEntrypoint(
  workPath: string,
  configuredEntrypoint: string
): Promise<string | null> {
  const entry = configuredEntrypoint.endsWith('.go')
    ? configuredEntrypoint
    : `${configuredEntrypoint}.go`;

  try {
    const fsFiles = await glob('**', workPath);
    // If the configured entrypoint exists, use it
    if (fsFiles[entry]) return entry;

    // Otherwise search for candidates
    const candidates = GIN_CANDIDATE_ENTRYPOINTS.filter(
      (c: string) => !!fsFiles[c]
    );
    if (candidates.length > 0) {
      const ginEntrypoint =
        candidates.find((c: string) =>
          isGinEntrypoint(fsFiles[c] as FileFsRef)
        ) || candidates[0];
      debug(`Detected Gin entrypoint: ${ginEntrypoint}`);
      return ginEntrypoint;
    }

    // Nothing found
    return null;
  } catch {
    debug('Failed to discover entrypoint for Gin');
    return null;
  }
}

// Attempt to find an exported Engine provider usable for zero-config wrapping.
// Supported patterns:
// - var Router *gin.Engine    (exported var)
// - func SetupRouter() *gin.Engine  (exported zero-arg func returning *gin.Engine)
export async function detectGinAccessor(
  workPath: string,
  entrypointRel: string
): Promise<{ kind: 'var' | 'func'; name: string } | null> {
  try {
    const dirRel = pathPosix.dirname(entrypointRel);
    const files = await glob('*.go', pathPosix.join(workPath, dirRel));
    const varRe = /\bvar\s+([A-Z]\w*)\s*\*\s*gin\.Engine\b/;
    const funcRe = /\bfunc\s+([A-Z]\w*)\s*\(\s*\)\s*\*\s*gin\.Engine\b/;
    const importRe = /"github.com\/gin-gonic\/gin"/;
    let varName: string | null = null;
    let funcName: string | null = null;
    for (const f of Object.values(files)) {
      const fsPath = (f as FileFsRef).fsPath;
      const content = fs.readFileSync(fsPath, 'utf8');
      if (!importRe.test(content)) continue;
      if (!funcName) {
        const m = content.match(funcRe);
        if (m) funcName = m[1];
      }
      if (!varName) {
        const m2 = content.match(varRe);
        if (m2) varName = m2[1];
      }
    }
    if (funcName) return { kind: 'func', name: funcName };
    if (varName) return { kind: 'var', name: varName };
    return null;
  } catch {
    return null;
  }
}

export function renderGinWrapperSource(
  pkgName: string,
  acc: { kind: 'var' | 'func'; name: string },
  funcName = 'VercelGinHandler'
): string {
  const importSync = acc.kind === 'func' ? '\n\t"sync"' : '';
  const onceDecl =
    acc.kind === 'func'
      ? '\nvar __vc_gin_once sync.Once\nvar __vc_gin_handler http.Handler'
      : '';
  const body =
    acc.kind === 'var'
      ? `${acc.name}.ServeHTTP(w, r)`
      : `__vc_gin_once.Do(func(){ __vc_gin_handler = ${acc.name}() })\n\t__vc_gin_handler.ServeHTTP(w, r)`;
  return `package ${pkgName}

import (
\t"net/http"${importSync}
)

${onceDecl}

// Auto-generated by Vercel: wraps Gin Engine for Serverless
func ${funcName}(w http.ResponseWriter, r *http.Request) {
\t${body}
}
`;
}
